import java.util.LinkedList;
import java.util.Queue;

/*
 *  9. Write a Java program that implements a producer-consumer model using
       multithreading. The program should have a producer thread that generates random
       numbers and adds them to a queue, and a consumer thread that reads numbers
       from the queue and calculates their sum. The program should use synchronization to
       ensure that the queue is accessed by only one thread at a time.
 */
// class Q{
//	
//	private int i;
//	 boolean flag=false;
//
//	public int getI() {
//		return i;
//	}
//
//	public void setI(int i) {
//		this.i = i;
//	}
//
////	public boolean isFlag() {
////		return flag;
////	}
////
////	public void setFlag(boolean flag) {
////		this.flag = flag;
////	}
//	
// }
 class Producer extends Thread
 {
	 LinkedList q;
	 
	 Producer(LinkedList q){
		 
		 System.out.println("Object is Created");
		 this.q=q;
	 }
	 
	 @Override
	public void run(){
		 //int k=0;
		synchronized(this) {
			for(int j=0;j<10;j++) {
			// k+= j;
				
				//q.setI(j);
				q.add(j);
			 System.out.println("dsgddh"+j);
			}
			q.flag=true;
			 this.notify();
		}
	 }
	 
 }
 class Consumer extends Thread
 {
	 int k=0;
     // Q q;
      LinkedList q;
	 Consumer(LinkedList q){
		 System.out.println("Object is created for Consumer Thread");
		 this.q=q;
	 }
	 
	 @Override
	public void run(){
	      synchronized(this) {
	    	  if(!q.flag) {
	    	  try {
				this.wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	      }
	      else {
	      k+= q.getI();
	      System.out.println("**************"+q.getI());
	      System.out.println("Total Sum Of Number Which Producer Produce::"+k);
	      }
	 }
	 }
 }
	 
public class TestApp {

	public static void main(String[] args) {
		Q q=new Q();
		Queue list = new LinkedList();
		Producer p = new Producer(list);
		Consumer c = new Consumer(list);
		p.start();
		c.start();
		
		System.out.println("Main Thread");
		

	}
}

