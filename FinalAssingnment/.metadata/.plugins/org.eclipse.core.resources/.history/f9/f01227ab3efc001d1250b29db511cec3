import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;

/*
 *  9. Write a Java program that implements a producer-consumer model using
       multithreading. The program should have a producer thread that generates random
       numbers and adds them to a queue, and a consumer thread that reads numbers
       from the queue and calculates their sum. The program should use synchronization to
       ensure that the queue is accessed by only one thread at a time.
 */
class Q{
	private int i;
	private boolean flag;
	 Queue q=new LinkedList();
	public int getI() {
		return i;
	}
	public void setI(int i) {
		this.i = i;
	}
	public boolean isFlag() {
		return flag;
	}
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
	public Queue getQ() {
		return q;
	}
	public void setQ(int j) {
		q.add(j);
		
	}
}
class Producer implements Runnable{
     Q q;
	Producer(Q q){
		this.q=q;
	}
     @Override
	public void run() { 
    	 synchronized(this) {
		for(int j=1;j<10;j++) {
			q.setQ(j);
			
			System.out.println("****"+j);
			
		}
		System.out.println("//**/***"+q.getQ());
		q.setFlag(true);
		this.notify(); 	
	}	
}
}
class Consumer implements Runnable{
	Q q;
	Consumer(Q q){
		this.q=q;
	}
	@Override
	public void run() {
	 synchronized(this) {
		 if(q.isFlag()) {
			 
			 Queue q2 = q.getQ();
			 Iterator it = q2.iterator();
			 while(it.hasNext()) {
				 Integer next =  (Integer) it.next();
				 System.out.println("///////////////"+next);
			 
		 }
		
		 }
		 else {
			 try {
				 this.wait();
			 } catch (InterruptedException e) {
				 // TODO Auto-generated catch block
				 e.printStackTrace();
			 }
		 }
	 }
		
	}	
}
	 
public class TestApp {

	public static void main(String[] args) {
		Q q=new Q();
	Producer P = new Producer(q);
	Consumer C = new Consumer(q);
	Thread t1 = new Thread(P);
	Thread t2 = new Thread(C);
	
	t1.start();
	t2.start();
	
	System.out.println("Main Thread");
	}
}

