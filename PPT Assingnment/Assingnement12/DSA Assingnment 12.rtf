{\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 1. Given a singly linked list, delete middle of the linked list. For example, if given linked list is 1->2->3->4->5 then linked list should be modified to 1->2->4->5.If there are even nodes, then there would be two middle nodes, we need to delete the second middle element. For example, if given linked list is 1->2->3->4->5->6 then it should be modified to 1->2->3->5->6.If the input linked list is NULL or has 1 node, then it should return NULL\par
Ans:\par
import java.io.*;\par
class deleteLinkedList \{\par
\tab /* Link list Node */\par
\tab static class Node \{\par
\tab\tab int data;\par
\tab\tab Node next;\par
\tab\}\par
\tab // Utility function to create a new node.\par
\tab static Node newNode(int data)\par
\tab\{\par
\tab\tab Node temp = new Node();\par
\tab\tab temp.data = data;\par
\tab\tab temp.next = null;\par
\tab\tab return temp;\par
\tab\}\par
\tab // count of nodes\par
\tab static int countOfNodes(Node head)\par
\tab\{\par
\tab\tab int count = 0;\par
\tab\tab while (head != null) \{\par
\tab\tab\tab head = head.next;\par
\tab\tab\tab count++;\par
\tab\tab\}\par
\tab\tab return count;\par
\tab\}\par
\tab // Deletes middle node and returns\par
\tab // head of the modified list\par
\tab static Node deleteMid(Node head)\par
\tab\{\par
\tab\tab // Base cases\par
\tab\tab if (head == null)\par
\tab\tab\tab return null;\par
\tab\tab if (head.next == null) \{\par
\tab\tab\tab return null;\par
\tab\tab\}\par
\tab\tab Node copyHead = head;\par
\par
\tab\tab // Find the count of nodes\par
\tab\tab int count = countOfNodes(head);\par
\par
\tab\tab // Find the middle node\par
\tab\tab int mid = count / 2;\par
\par
\tab\tab // Delete the middle node\par
\tab\tab while (mid-- > 1) \{\par
\tab\tab\tab head = head.next;\par
\tab\tab\}\par
\par
\tab\tab // Delete the middle node\par
\tab\tab head.next = head.next.next;\par
\par
\tab\tab return copyHead;\par
\tab\}\par
\par
\tab // A utility function to print\par
\tab // a given linked list\par
\tab static void printList(Node ptr)\par
\tab\{\par
\tab\tab while (ptr != null) \{\par
\tab\tab\tab System.out.print(ptr.data + "->");\par
\tab\tab\tab ptr = ptr.next;\par
\tab\tab\}\par
\tab\tab System.out.println("NULL");\par
\tab\}\par
\par
\tab /* Driver code*/\par
\tab public static void main(String[] args)\par
\tab\{\par
\tab\tab /* Start with the empty list */\par
\tab\tab Node head = newNode(1);\par
\tab\tab head.next = newNode(2);\par
\tab\tab head.next.next = newNode(3);\par
\tab\tab head.next.next.next = newNode(4);\par
\par
\tab\tab System.out.println("Given Linked List");\par
\tab\tab printList(head);\par
\par
\tab\tab head = deleteMid(head);\par
\par
\tab\tab System.out.println(\par
\tab\tab\tab "Linked List after deletion of middle");\par
\tab\tab printList(head);\par
\tab\}\par
\}\par
\fs36 2. Given a linked list of\~N\~nodes. The task is to check if the\~linked list has a loop. Linked list can contain\~self loop..\par
Ans:\par
\fs22 import java.util.*;\par
\par
public class LinkedList \{\par
\tab static Node head; // head of list\par
\tab /* Linked list Node*/\par
\tab static class Node \{\par
\tab\tab int data;\par
\tab\tab Node next;\par
\tab\tab Node(int d)\par
\tab\tab\{\par
\tab\tab\tab data = d;\par
\tab\tab\tab next = null;\par
\tab\tab\}\par
\tab\}\par
\tab /* Inserts a new Node at front of the list. */\par
\tab static public void push(int new_data)\par
\tab\{\par
\tab\tab /* 1 & 2: Allocate the Node &\par
\tab\tab\tab\tab Put in the data*/\par
\tab\tab Node new_node = new Node(new_data);\par
\par
\tab\tab /* 3. Make next of new Node as head */\par
\tab\tab new_node.next = head;\par
\par
\tab\tab /* 4. Move the head to point to new Node */\par
\tab\tab head = new_node;\par
\tab\}\par
\tab // Returns true if there is a loop in linked\par
\tab // list else returns false.\par
\tab static boolean detectLoop(Node h)\par
\tab\{\par
\tab\tab HashSet<Node> s = new HashSet<Node>();\par
\tab\tab while (h != null) \{\par
\tab\tab\tab // If we have already has this node\par
\tab\tab\tab // in hashmap it means there is a cycle\par
\tab\tab\tab // (Because you we encountering the\par
\tab\tab\tab // node second time).\par
\tab\tab\tab if (s.contains(h))\par
\tab\tab\tab\tab return true;\par
\par
\tab\tab\tab // If we are seeing the node for\par
\tab\tab\tab // the first time, insert it in hash\par
\tab\tab\tab s.add(h);\par
\par
\tab\tab\tab h = h.next;\par
\tab\tab\}\par
\par
\tab\tab return false;\par
\tab\}\par
\par
\tab /* Driver program to test above function */\par
\tab public static void main(String[] args)\par
\tab\{\par
\tab\tab LinkedList llist = new LinkedList();\par
\par
\tab\tab llist.push(20);\par
\tab\tab llist.push(4);\par
\tab\tab llist.push(15);\par
\tab\tab llist.push(10);\par
\tab\tab /*Create loop for testing */\par
\tab\tab llist.head.next.next.next.next = llist.head;\par
\tab\tab if (detectLoop(head))\par
\tab\tab\tab System.out.println("Loop Found");\par
\tab\tab else\par
\tab\tab\tab System.out.println("No Loop");\par
\tab\}\par
\}\par
\fs40 3. Given a linked list consisting of\~L\~nodes and given a number\~N. The task is to find the\~Nth\~node from the end of the linked list.\par
Ans:\par
\fs24 import java.io.*;\par
class LinkedList \{\par
\tab Node head; // head of the list\par
\par
\tab /* Linked List node */\par
\tab class Node \{\par
\tab\tab int data;\par
\tab\tab Node next;\par
\tab\tab Node(int d)\par
\tab\tab\{\par
\tab\tab\tab data = d;\par
\tab\tab\tab next = null;\par
\tab\tab\}\par
\tab\}\par
\par
\tab /* Function to get the Nth node from the last of a\par
\tab linked list */\par
\tab void printNthFromLast(int N)\par
\tab\{\par
\tab\tab int len = 0;\par
\tab\tab Node temp = head;\par
\par
\tab\tab // 1) count the number of nodes in Linked List\par
\tab\tab while (temp != null) \{\par
\tab\tab\tab temp = temp.next;\par
\tab\tab\tab len++;\par
\tab\tab\}\par
\par
\tab\tab // check if value of N is not more than length of\par
\tab\tab // the linked list\par
\tab\tab if (len < N)\par
\tab\tab\tab return;\par
\par
\tab\tab temp = head;\par
\par
\tab\tab // 2) get the (len-N+1)th node from the beginning\par
\tab\tab for (int i = 1; i < len - N + 1; i++)\par
\tab\tab\tab temp = temp.next;\par
\par
\tab\tab System.out.println(temp.data);\par
\tab\}\par
\tab /* Inserts a new Node at front of the list. */\par
\tab public void push(int new_data)\par
\tab\{\par
\tab\tab /* 1 & 2: Allocate the Node &\par
\tab\tab\tab\tab Put in the data*/\par
\tab\tab Node new_node = new Node(new_data);\par
\par
\tab\tab /* 3. Make next of new Node as head */\par
\tab\tab new_node.next = head;\par
\tab\tab /* 4. Move the head to point to new Node */\par
\tab\tab head = new_node;\par
\tab\}\par
\tab // Driver's code\par
\tab public static void main(String[] args)\par
\tab\{\par
\tab\tab LinkedList llist = new LinkedList();\par
\tab\tab llist.push(20);\par
\tab\tab llist.push(4);\par
\tab\tab llist.push(15);\par
\tab\tab llist.push(35);\par
\tab\tab\par
\tab\tab // Function call\par
\tab\tab llist.printNthFromLast(4);\par
\tab\}\par
\} \par
\fs40 4. Given a singly linked list of characters, write a function that returns true if the given list is a palindrome, else false.\par
Ans: \par
\fs24 import java.util.*;\par
class linkedList \{\par
\tab public static void main(String args[])\par
\tab\{\par
\tab\tab Node one = new Node(1);\par
\tab\tab Node two = new Node(2);\par
\tab\tab Node three = new Node(3);\par
\tab\tab Node four = new Node(4);\par
\tab\tab Node five = new Node(3);\par
\tab\tab Node six = new Node(2);\par
\tab\tab Node seven = new Node(1);\par
\tab\tab one.ptr = two;\par
\tab\tab two.ptr = three;\par
\tab\tab three.ptr = four;\par
\tab\tab four.ptr = five;\par
\tab\tab five.ptr = six;\par
\tab\tab six.ptr = seven;\par
\tab\tab boolean condition = isPalindrome(one);\par
\tab\tab System.out.println("isPalidrome :" + condition);\par
\tab\}\par
\tab static boolean isPalindrome(Node head)\par
\tab\{\par
\par
\tab\tab Node slow = head;\par
\tab\tab boolean ispalin = true;\par
\tab\tab Stack<Integer> stack = new Stack<Integer>();\par
\par
\tab\tab while (slow != null) \{\par
\tab\tab\tab stack.push(slow.data);\par
\tab\tab\tab slow = slow.ptr;\par
\tab\tab\}\par
\par
\tab\tab while (head != null) \{\par
\par
\tab\tab\tab int i = stack.pop();\par
\tab\tab\tab if (head.data == i) \{\par
\tab\tab\tab\tab ispalin = true;\par
\tab\tab\tab\}\par
\tab\tab\tab else \{\par
\tab\tab\tab\tab ispalin = false;\par
\tab\tab\tab\tab break;\par
\tab\tab\tab\}\par
\tab\tab\tab head = head.ptr;\par
\tab\tab\}\par
\tab\tab return ispalin;\par
\tab\}\par
\}\par
\par
class Node \{\par
\tab int data;\par
\tab Node ptr;\par
\tab Node(int d)\par
\tab\{\par
\tab\tab ptr = null;\par
\tab\tab data = d;\par
\tab\}\par
\}\par
\fs40 5. Given a linked list of\~**N**\~nodes such that it may contain a loop.\par
A loop here means that the last node of the link list is connected to the node at position X(1-based index). If the link list does not have any loop, X=0.\par
Remove the loop from the linked list, if it is present, i.e. unlink the last node which is forming the loop.\par
\par
Ans:\fs24\par
class LinkedList \{\par
\par
\tab static Node head;\par
\par
\tab static class Node \{\par
\par
\tab\tab int data;\par
\tab\tab Node next;\par
\par
\tab\tab Node(int d)\par
\tab\tab\{\par
\tab\tab\tab data = d;\par
\tab\tab\tab next = null;\par
\tab\tab\}\par
\tab\}\par
\par
\tab // Function that detects loop in the list\par
\tab int detectAndRemoveLoop(Node node)\par
\tab\{\par
\tab\tab Node slow = node, fast = node;\par
\tab\tab while (slow != null && fast != null\par
\tab\tab\tab && fast.next != null) \{\par
\tab\tab\tab slow = slow.next;\par
\tab\tab\tab fast = fast.next.next;\par
\par
\tab\tab\tab // If slow and fast meet at same point then loop\par
\tab\tab\tab // is present\par
\tab\tab\tab if (slow == fast) \{\par
\tab\tab\tab\tab removeLoop(slow, node);\par
\tab\tab\tab\tab return 1;\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab // Function to remove loop\par
\tab void removeLoop(Node loop, Node head)\par
\tab\{\par
\tab\tab Node ptr1 = loop;\par
\tab\tab Node ptr2 = loop;\par
\par
\tab\tab // Count the number of nodes in loop\par
\tab\tab int k = 1, i;\par
\tab\tab Node prevNode = ptr1;\par
\tab\tab while (ptr1.next != ptr2) \{\par
\tab\tab\tab // keeping track beforeing moving next\par
\tab\tab\tab prevNode = ptr1;\par
\tab\tab\tab ptr1 = ptr1.next;\par
\tab\tab\tab k++;\par
\tab\tab\}\par
\tab\tab prevNode.next = null;\par
\tab\}\par
\par
\tab // Function to print the linked list\par
\tab void printList(Node node)\par
\tab\{\par
\tab\tab while (node != null) \{\par
\tab\tab\tab System.out.print(node.data + " ");\par
\tab\tab\tab node = node.next;\par
\tab\tab\}\par
\tab\}\par
\par
\tab // Driver program to test above functions\par
\tab public static void main(String[] args)\par
\tab\{\par
\tab\tab LinkedList list = new LinkedList();\par
\tab\tab list.head = new Node(50);\par
\tab\tab list.head.next = new Node(20);\par
\tab\tab list.head.next.next = new Node(15);\par
\tab\tab list.head.next.next.next = new Node(4);\par
\tab\tab list.head.next.next.next.next = new Node(10);\par
\par
\tab\tab // Creating a loop for testing\par
\tab\tab head.next.next.next.next.next = head.next.next;\par
\tab\tab list.detectAndRemoveLoop(head);\par
\tab\tab System.out.println(\par
\tab\tab\tab "Linked List after removing loop : ");\par
\tab\tab list.printList(head);\par
\tab\}\par
\}\par
\fs40 6. Given a linked list and two integers M and N. Traverse the linked list such that you retain M nodes then delete next N nodes, continue the same till end of the linked list.\par
Ans:\par
\fs24 import java.util.*;\par
class LinkedList\par
\{\par
\par
// A linked list node\par
static class Node\par
\{\par
\tab int data;\par
\tab Node next;\par
\};\par
\par
/* Function to insert a node at the beginning */\par
static Node push( Node head_ref, int new_data)\par
\{\par
\tab /* allocate node */\par
\tab Node new_node = new Node();\par
\par
\tab /* put in the data */\par
\tab new_node.data = new_data;\par
\par
\tab /* link the old list of the new node */\par
\tab new_node.next = (head_ref);\par
\par
\tab /* move the head to point to the new node */\par
\tab (head_ref) = new_node;\par
\tab\par
\tab return head_ref;\par
\}\par
\par
/* Function to print linked list */\par
static void printList( Node head)\par
\{\par
\tab Node temp = head;\par
\tab while (temp != null)\par
\tab\{\par
\tab\tab System.out.printf("%d ", temp.data);\par
\tab\tab temp = temp.next;\par
\tab\}\par
\tab System.out.printf("\\n");\par
\}\par
\par
// Function to skip M nodes and then\par
// delete N nodes of the linked list.\par
static void skipMdeleteN( Node head, int M, int N)\par
\{\par
\tab Node curr = head, t;\par
\tab int count;\par
\par
\tab // The main loop that traverses\par
\tab // through the whole list\par
\tab while (curr!=null)\par
\tab\{\par
\tab\tab // Skip M nodes\par
\tab\tab for (count = 1; count < M && curr != null; count++)\par
\tab\tab\tab curr = curr.next;\par
\par
\tab\tab // If we reached end of list, then return\par
\tab\tab if (curr == null)\par
\tab\tab\tab return;\par
\par
\tab\tab // Start from next node and delete N nodes\par
\tab\tab t = curr.next;\par
\tab\tab for (count = 1; count <= N && t != null; count++)\par
\tab\tab\{\par
\tab\tab\tab Node temp = t;\par
\tab\tab\tab t = t.next;\par
\tab\tab\}\par
\tab\tab\par
\tab\tab // Link the previous list with remaining nodes\par
\tab\tab curr.next = t;\par
\par
\tab\tab // Set current pointer for next iteration\par
\tab\tab curr = t;\par
\tab\}\par
\}\par
\par
// Driver code\par
public static void main(String args[])\par
\{\par
\tab /* Create following linked list\par
\tab 1.2.3.4.5.6.7.8.9.10 */\par
\tab Node head = null;\par
\tab int M=2, N=3;\par
\tab head=push(head, 10);\par
\tab head=push(head, 9);\par
\tab head=push(head, 8);\par
\tab head=push(head, 7);\par
\tab head=push(head, 6);\par
\tab head=push(head, 5);\par
\tab head=push(head, 4);\par
\tab head=push(head, 3);\par
\tab head=push(head, 2);\par
\tab head=push(head, 1);\par
\par
\tab System.out.printf("M = %d, N = %d \\nGiven" +\par
\tab\tab\tab\tab\tab\tab "Linked list is :\\n", M, N);\par
\tab printList(head);\par
\par
\tab skipMdeleteN(head, M, N);\par
\par
\tab System.out.printf("\\nLinked list after deletion is :\\n");\par
\tab printList(head);\par
\}\par
\}\par
\fs40 7. Given two linked lists, insert nodes of second list into first list at alternate positions of first list.\par
For example, if first list is 5->7->17->13->11 and second is 12->10->2->4->6, the first list should become 5->12->7->10->17->2->13->4->11->6 and second list should become empty. The nodes of second list should only be inserted when there are positions available. For example, if the first list is 1->2->3 and second list is 4->5->6->7->8, then first list should become 1->4->2->5->3->6 and second list to 7->8.\par
Use of extra space is not allowed (Not allowed to create additional nodes), i.e., insertion must be done in-place. Expected time complexity is O(n) where n is number of nodes in first list.\par
\par
Ans:\par
\fs24 class LinkedList\par
\{\par
\tab Node head; // head of list\par
\par
\tab /* Linked list Node*/\par
\tab class Node\par
\tab\{\par
\tab\tab int data;\par
\tab\tab Node next;\par
\tab\tab Node(int d) \{data = d; next = null; \}\par
\tab\}\par
\par
\tab /* Inserts a new Node at front of the list. */\par
\tab void push(int new_data)\par
\tab\{\par
\tab\tab /* 1 & 2: Allocate the Node &\par
\tab\tab\tab\tab Put in the data*/\par
\tab\tab Node new_node = new Node(new_data);\par
\par
\tab\tab /* 3. Make next of new Node as head */\par
\tab\tab new_node.next = head;\par
\par
\tab\tab /* 4. Move the head to point to new Node */\par
\tab\tab head = new_node;\par
\tab\}\par
\par
\tab // Main function that inserts nodes of linked list q into p at\par
\tab // alternate positions. Since head of first list never changes\par
\tab // and head of second list/ may change, we need single pointer\par
\tab // for first list and double pointer for second list.\par
\tab void merge(LinkedList q)\par
\tab\{\par
\tab\tab Node p_curr = head, q_curr = q.head;\par
\tab\tab Node p_next, q_next;\par
\par
\tab\tab // While there are available positions in p;\par
\tab\tab while (p_curr != null && q_curr != null) \{\par
\par
\tab\tab\tab // Save next pointers\par
\tab\tab\tab p_next = p_curr.next;\par
\tab\tab\tab q_next = q_curr.next;\par
\par
\tab\tab\tab // make q_curr as next of p_curr\par
\tab\tab\tab q_curr.next = p_next; // change next pointer of q_curr\par
\tab\tab\tab p_curr.next = q_curr; // change next pointer of p_curr\par
\par
\tab\tab\tab // update current pointers for next iteration\par
\tab\tab\tab p_curr = p_next;\par
\tab\tab\tab q_curr = q_next;\par
\tab\tab\}\par
\tab\tab q.head = q_curr;\par
\tab\}\par
\par
\tab /* Function to print linked list */\par
\tab void printList()\par
\tab\{\par
\tab\tab Node temp = head;\par
\tab\tab while (temp != null)\par
\tab\tab\{\par
\tab\tab System.out.print(temp.data+" ");\par
\tab\tab temp = temp.next;\par
\tab\tab\}\par
\tab\tab System.out.println();\par
\tab\}\par
\par
\tab /* Driver program to test above functions */\par
\tab public static void main(String args[])\par
\tab\{\par
\tab\tab LinkedList llist1 = new LinkedList();\par
\tab\tab LinkedList llist2 = new LinkedList();\par
\tab\tab llist1.push(3);\par
\tab\tab llist1.push(2);\par
\tab\tab llist1.push(1);\par
\par
\tab\tab System.out.println("First Linked List:");\par
\tab\tab llist1.printList();\par
\par
\tab\tab llist2.push(8);\par
\tab\tab llist2.push(7);\par
\tab\tab llist2.push(6);\par
\tab\tab llist2.push(5);\par
\tab\tab llist2.push(4);\par
\par
\tab\tab System.out.println("Second Linked List:");\par
\par
\tab\tab llist1.merge(llist2);\par
\par
\tab\tab System.out.println("Modified first linked list:");\par
\tab\tab llist1.printList();\par
\par
\tab\tab System.out.println("Modified second linked list:");\par
\tab\tab llist2.printList();\par
\tab\}\par
\} \par
\fs40 8.Given a singly linked list, find if the linked list is\~\par
 A linked list is called circular if it is not NULL-terminated and all nodes are connected in the form of a cycle. Below is an example of a circular linked list.\par
 Ans:\fs24\par
import java.util.*;\par
\par
class LinkedList \{\par
\tab /* Link list Node */\par
\tab static class Node \{\par
\tab\tab int data;\par
\tab\tab Node next;\par
\tab\}\par
\tab /*This function returns true if given linked\par
\tab list is circular, else false. */\par
\tab static boolean isCircular(Node head)\par
\tab\{\par
\tab\tab // An empty linked list is circular\par
\tab\tab if (head == null)\par
\tab\tab\tab return true;\par
\par
\tab\tab // Next of head\par
\tab\tab Node node = head.next;\par
\par
\tab\tab // This loop would stop in both cases (1) If\par
\tab\tab // Circular (2) Not circular\par
\tab\tab while (node != null && node != head)\par
\tab\tab\tab node = node.next;\par
\par
\tab\tab // If loop stopped because of circular\par
\tab\tab // condition\par
\tab\tab return (node == head);\par
\tab\}\par
\par
\tab // Utility function to create a new node.\par
\tab static Node newNode(int data)\par
\tab\{\par
\tab\tab Node temp = new Node();\par
\tab\tab temp.data = data;\par
\tab\tab temp.next = null;\par
\tab\tab return temp;\par
\tab\}\par
\par
\tab /* Driver code*/\par
\tab public static void main(String args[])\par
\tab\{\par
\tab\tab /* Start with the empty list */\par
\tab\tab Node head = newNode(1);\par
\tab\tab head.next = newNode(2);\par
\tab\tab head.next.next = newNode(3);\par
\tab\tab head.next.next.next = newNode(4);\par
\par
\tab\tab System.out.print(isCircular(head) ? "Yes\\n": "No\\n");\par
\par
\tab\tab // Making linked list circular\par
\tab\tab head.next.next.next.next = head;\par
\par
\tab\tab System.out.print(isCircular(head) ? "Yes\\n": "No\\n");\par
\tab\}\par
\}\par
\par
\par
}
 